// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OS.Network.proto

#ifndef PROTOBUF_OS_2eNetwork_2eproto__INCLUDED
#define PROTOBUF_OS_2eNetwork_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace cloudos {
namespace config {
namespace os {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_OS_2eNetwork_2eproto();
void protobuf_AssignDesc_OS_2eNetwork_2eproto();
void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

class NetworkRoute;
class NetworkInterface;
class SSHTunnel;
class WebProtocol;
class SSLSettings;

enum NetworkRoute_Type {
  NetworkRoute_Type_VIA = 0,
  NetworkRoute_Type_DEV = 1
};
bool NetworkRoute_Type_IsValid(int value);
const NetworkRoute_Type NetworkRoute_Type_Type_MIN = NetworkRoute_Type_VIA;
const NetworkRoute_Type NetworkRoute_Type_Type_MAX = NetworkRoute_Type_DEV;
const int NetworkRoute_Type_Type_ARRAYSIZE = NetworkRoute_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkRoute_Type_descriptor();
inline const ::std::string& NetworkRoute_Type_Name(NetworkRoute_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkRoute_Type_descriptor(), value);
}
inline bool NetworkRoute_Type_Parse(
    const ::std::string& name, NetworkRoute_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkRoute_Type>(
    NetworkRoute_Type_descriptor(), name, value);
}
enum WebProtocol_Type {
  WebProtocol_Type_HTTP = 0,
  WebProtocol_Type_HTTPS = 1
};
bool WebProtocol_Type_IsValid(int value);
const WebProtocol_Type WebProtocol_Type_Type_MIN = WebProtocol_Type_HTTP;
const WebProtocol_Type WebProtocol_Type_Type_MAX = WebProtocol_Type_HTTPS;
const int WebProtocol_Type_Type_ARRAYSIZE = WebProtocol_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebProtocol_Type_descriptor();
inline const ::std::string& WebProtocol_Type_Name(WebProtocol_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebProtocol_Type_descriptor(), value);
}
inline bool WebProtocol_Type_Parse(
    const ::std::string& name, WebProtocol_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebProtocol_Type>(
    WebProtocol_Type_descriptor(), name, value);
}
// ===================================================================

class NetworkRoute : public ::google::protobuf::Message {
 public:
  NetworkRoute();
  virtual ~NetworkRoute();

  NetworkRoute(const NetworkRoute& from);

  inline NetworkRoute& operator=(const NetworkRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkRoute& default_instance();

  void Swap(NetworkRoute* other);

  // implements Message ----------------------------------------------

  NetworkRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkRoute& from);
  void MergeFrom(const NetworkRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NetworkRoute_Type Type;
  static const Type VIA = NetworkRoute_Type_VIA;
  static const Type DEV = NetworkRoute_Type_DEV;
  static inline bool Type_IsValid(int value) {
    return NetworkRoute_Type_IsValid(value);
  }
  static const Type Type_MIN =
    NetworkRoute_Type_Type_MIN;
  static const Type Type_MAX =
    NetworkRoute_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    NetworkRoute_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return NetworkRoute_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return NetworkRoute_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return NetworkRoute_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .cloudos.config.os.NetworkRoute.Type type = 2 [default = VIA];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::cloudos::config::os::NetworkRoute_Type type() const;
  inline void set_type(::cloudos::config::os::NetworkRoute_Type value);

  // repeated string route_ip = 4;
  inline int route_ip_size() const;
  inline void clear_route_ip();
  static const int kRouteIpFieldNumber = 4;
  inline const ::std::string& route_ip(int index) const;
  inline ::std::string* mutable_route_ip(int index);
  inline void set_route_ip(int index, const ::std::string& value);
  inline void set_route_ip(int index, const char* value);
  inline void set_route_ip(int index, const char* value, size_t size);
  inline ::std::string* add_route_ip();
  inline void add_route_ip(const ::std::string& value);
  inline void add_route_ip(const char* value);
  inline void add_route_ip(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& route_ip() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_route_ip();

  // optional string index = 6;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 6;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const char* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // @@protoc_insertion_point(class_scope:cloudos.config.os.NetworkRoute)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> route_ip_;
  ::std::string* index_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OS_2eNetwork_2eproto();
  friend void protobuf_AssignDesc_OS_2eNetwork_2eproto();
  friend void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

  void InitAsDefaultInstance();
  static NetworkRoute* default_instance_;
};
// -------------------------------------------------------------------

class NetworkInterface : public ::google::protobuf::Message {
 public:
  NetworkInterface();
  virtual ~NetworkInterface();

  NetworkInterface(const NetworkInterface& from);

  inline NetworkInterface& operator=(const NetworkInterface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInterface& default_instance();

  void Swap(NetworkInterface* other);

  // implements Message ----------------------------------------------

  NetworkInterface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkInterface& from);
  void MergeFrom(const NetworkInterface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const char* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // repeated string ip_cidr = 4;
  inline int ip_cidr_size() const;
  inline void clear_ip_cidr();
  static const int kIpCidrFieldNumber = 4;
  inline const ::std::string& ip_cidr(int index) const;
  inline ::std::string* mutable_ip_cidr(int index);
  inline void set_ip_cidr(int index, const ::std::string& value);
  inline void set_ip_cidr(int index, const char* value);
  inline void set_ip_cidr(int index, const char* value, size_t size);
  inline ::std::string* add_ip_cidr();
  inline void add_ip_cidr(const ::std::string& value);
  inline void add_ip_cidr(const char* value);
  inline void add_ip_cidr(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_cidr() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_cidr();

  // repeated string dns_server = 6;
  inline int dns_server_size() const;
  inline void clear_dns_server();
  static const int kDnsServerFieldNumber = 6;
  inline const ::std::string& dns_server(int index) const;
  inline ::std::string* mutable_dns_server(int index);
  inline void set_dns_server(int index, const ::std::string& value);
  inline void set_dns_server(int index, const char* value);
  inline void set_dns_server(int index, const char* value, size_t size);
  inline ::std::string* add_dns_server();
  inline void add_dns_server(const ::std::string& value);
  inline void add_dns_server(const char* value);
  inline void add_dns_server(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server();

  // repeated .cloudos.config.os.NetworkRoute route = 10;
  inline int route_size() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 10;
  inline const ::cloudos::config::os::NetworkRoute& route(int index) const;
  inline ::cloudos::config::os::NetworkRoute* mutable_route(int index);
  inline ::cloudos::config::os::NetworkRoute* add_route();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudos::config::os::NetworkRoute >&
      route() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudos::config::os::NetworkRoute >*
      mutable_route();

  // @@protoc_insertion_point(class_scope:cloudos.config.os.NetworkInterface)
 private:
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_cidr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_;
  ::google::protobuf::RepeatedPtrField< ::cloudos::config::os::NetworkRoute > route_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OS_2eNetwork_2eproto();
  friend void protobuf_AssignDesc_OS_2eNetwork_2eproto();
  friend void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

  void InitAsDefaultInstance();
  static NetworkInterface* default_instance_;
};
// -------------------------------------------------------------------

class SSHTunnel : public ::google::protobuf::Message {
 public:
  SSHTunnel();
  virtual ~SSHTunnel();

  SSHTunnel(const SSHTunnel& from);

  inline SSHTunnel& operator=(const SSHTunnel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSHTunnel& default_instance();

  void Swap(SSHTunnel* other);

  // implements Message ----------------------------------------------

  SSHTunnel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSHTunnel& from);
  void MergeFrom(const SSHTunnel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tunnel_name = 2;
  inline bool has_tunnel_name() const;
  inline void clear_tunnel_name();
  static const int kTunnelNameFieldNumber = 2;
  inline const ::std::string& tunnel_name() const;
  inline void set_tunnel_name(const ::std::string& value);
  inline void set_tunnel_name(const char* value);
  inline void set_tunnel_name(const char* value, size_t size);
  inline ::std::string* mutable_tunnel_name();
  inline ::std::string* release_tunnel_name();
  inline void set_allocated_tunnel_name(::std::string* tunnel_name);

  // optional string local_ip = 4 [default = "127.0.0.1"];
  inline bool has_local_ip() const;
  inline void clear_local_ip();
  static const int kLocalIpFieldNumber = 4;
  inline const ::std::string& local_ip() const;
  inline void set_local_ip(const ::std::string& value);
  inline void set_local_ip(const char* value);
  inline void set_local_ip(const char* value, size_t size);
  inline ::std::string* mutable_local_ip();
  inline ::std::string* release_local_ip();
  inline void set_allocated_local_ip(::std::string* local_ip);

  // optional int32 local_port = 6;
  inline bool has_local_port() const;
  inline void clear_local_port();
  static const int kLocalPortFieldNumber = 6;
  inline ::google::protobuf::int32 local_port() const;
  inline void set_local_port(::google::protobuf::int32 value);

  // optional string remote_ip = 8;
  inline bool has_remote_ip() const;
  inline void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 8;
  inline const ::std::string& remote_ip() const;
  inline void set_remote_ip(const ::std::string& value);
  inline void set_remote_ip(const char* value);
  inline void set_remote_ip(const char* value, size_t size);
  inline ::std::string* mutable_remote_ip();
  inline ::std::string* release_remote_ip();
  inline void set_allocated_remote_ip(::std::string* remote_ip);

  // optional int32 remote_port = 10;
  inline bool has_remote_port() const;
  inline void clear_remote_port();
  static const int kRemotePortFieldNumber = 10;
  inline ::google::protobuf::int32 remote_port() const;
  inline void set_remote_port(::google::protobuf::int32 value);

  // optional string remote_user = 12 [default = "root"];
  inline bool has_remote_user() const;
  inline void clear_remote_user();
  static const int kRemoteUserFieldNumber = 12;
  inline const ::std::string& remote_user() const;
  inline void set_remote_user(const ::std::string& value);
  inline void set_remote_user(const char* value);
  inline void set_remote_user(const char* value, size_t size);
  inline ::std::string* mutable_remote_user();
  inline ::std::string* release_remote_user();
  inline void set_allocated_remote_user(::std::string* remote_user);

  // optional string key_file = 20;
  inline bool has_key_file() const;
  inline void clear_key_file();
  static const int kKeyFileFieldNumber = 20;
  inline const ::std::string& key_file() const;
  inline void set_key_file(const ::std::string& value);
  inline void set_key_file(const char* value);
  inline void set_key_file(const char* value, size_t size);
  inline ::std::string* mutable_key_file();
  inline ::std::string* release_key_file();
  inline void set_allocated_key_file(::std::string* key_file);

  // @@protoc_insertion_point(class_scope:cloudos.config.os.SSHTunnel)
 private:
  inline void set_has_tunnel_name();
  inline void clear_has_tunnel_name();
  inline void set_has_local_ip();
  inline void clear_has_local_ip();
  inline void set_has_local_port();
  inline void clear_has_local_port();
  inline void set_has_remote_ip();
  inline void clear_has_remote_ip();
  inline void set_has_remote_port();
  inline void clear_has_remote_port();
  inline void set_has_remote_user();
  inline void clear_has_remote_user();
  inline void set_has_key_file();
  inline void clear_has_key_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tunnel_name_;
  ::std::string* local_ip_;
  static ::std::string* _default_local_ip_;
  ::std::string* remote_ip_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 remote_port_;
  ::std::string* remote_user_;
  static ::std::string* _default_remote_user_;
  ::std::string* key_file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OS_2eNetwork_2eproto();
  friend void protobuf_AssignDesc_OS_2eNetwork_2eproto();
  friend void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

  void InitAsDefaultInstance();
  static SSHTunnel* default_instance_;
};
// -------------------------------------------------------------------

class WebProtocol : public ::google::protobuf::Message {
 public:
  WebProtocol();
  virtual ~WebProtocol();

  WebProtocol(const WebProtocol& from);

  inline WebProtocol& operator=(const WebProtocol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebProtocol& default_instance();

  void Swap(WebProtocol* other);

  // implements Message ----------------------------------------------

  WebProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebProtocol& from);
  void MergeFrom(const WebProtocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef WebProtocol_Type Type;
  static const Type HTTP = WebProtocol_Type_HTTP;
  static const Type HTTPS = WebProtocol_Type_HTTPS;
  static inline bool Type_IsValid(int value) {
    return WebProtocol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    WebProtocol_Type_Type_MIN;
  static const Type Type_MAX =
    WebProtocol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    WebProtocol_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return WebProtocol_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return WebProtocol_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return WebProtocol_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .cloudos.config.os.WebProtocol.Type type = 2 [default = HTTPS];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::cloudos::config::os::WebProtocol_Type type() const;
  inline void set_type(::cloudos::config::os::WebProtocol_Type value);

  // @@protoc_insertion_point(class_scope:cloudos.config.os.WebProtocol)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OS_2eNetwork_2eproto();
  friend void protobuf_AssignDesc_OS_2eNetwork_2eproto();
  friend void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

  void InitAsDefaultInstance();
  static WebProtocol* default_instance_;
};
// -------------------------------------------------------------------

class SSLSettings : public ::google::protobuf::Message {
 public:
  SSLSettings();
  virtual ~SSLSettings();

  SSLSettings(const SSLSettings& from);

  inline SSLSettings& operator=(const SSLSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSLSettings& default_instance();

  void Swap(SSLSettings* other);

  // implements Message ----------------------------------------------

  SSLSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SSLSettings& from);
  void MergeFrom(const SSLSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ca_file = 2;
  inline bool has_ca_file() const;
  inline void clear_ca_file();
  static const int kCaFileFieldNumber = 2;
  inline const ::std::string& ca_file() const;
  inline void set_ca_file(const ::std::string& value);
  inline void set_ca_file(const char* value);
  inline void set_ca_file(const char* value, size_t size);
  inline ::std::string* mutable_ca_file();
  inline ::std::string* release_ca_file();
  inline void set_allocated_ca_file(::std::string* ca_file);

  // optional string cert_file = 4;
  inline bool has_cert_file() const;
  inline void clear_cert_file();
  static const int kCertFileFieldNumber = 4;
  inline const ::std::string& cert_file() const;
  inline void set_cert_file(const ::std::string& value);
  inline void set_cert_file(const char* value);
  inline void set_cert_file(const char* value, size_t size);
  inline ::std::string* mutable_cert_file();
  inline ::std::string* release_cert_file();
  inline void set_allocated_cert_file(::std::string* cert_file);

  // optional string key_file = 6;
  inline bool has_key_file() const;
  inline void clear_key_file();
  static const int kKeyFileFieldNumber = 6;
  inline const ::std::string& key_file() const;
  inline void set_key_file(const ::std::string& value);
  inline void set_key_file(const char* value);
  inline void set_key_file(const char* value, size_t size);
  inline ::std::string* mutable_key_file();
  inline ::std::string* release_key_file();
  inline void set_allocated_key_file(::std::string* key_file);

  // optional bool allow_untrusted = 8 [default = false];
  inline bool has_allow_untrusted() const;
  inline void clear_allow_untrusted();
  static const int kAllowUntrustedFieldNumber = 8;
  inline bool allow_untrusted() const;
  inline void set_allow_untrusted(bool value);

  // @@protoc_insertion_point(class_scope:cloudos.config.os.SSLSettings)
 private:
  inline void set_has_ca_file();
  inline void clear_has_ca_file();
  inline void set_has_cert_file();
  inline void clear_has_cert_file();
  inline void set_has_key_file();
  inline void clear_has_key_file();
  inline void set_has_allow_untrusted();
  inline void clear_has_allow_untrusted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ca_file_;
  ::std::string* cert_file_;
  ::std::string* key_file_;
  bool allow_untrusted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OS_2eNetwork_2eproto();
  friend void protobuf_AssignDesc_OS_2eNetwork_2eproto();
  friend void protobuf_ShutdownFile_OS_2eNetwork_2eproto();

  void InitAsDefaultInstance();
  static SSLSettings* default_instance_;
};
// ===================================================================


// ===================================================================

// NetworkRoute

// optional .cloudos.config.os.NetworkRoute.Type type = 2 [default = VIA];
inline bool NetworkRoute::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkRoute::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkRoute::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkRoute::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cloudos::config::os::NetworkRoute_Type NetworkRoute::type() const {
  return static_cast< ::cloudos::config::os::NetworkRoute_Type >(type_);
}
inline void NetworkRoute::set_type(::cloudos::config::os::NetworkRoute_Type value) {
  assert(::cloudos::config::os::NetworkRoute_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated string route_ip = 4;
inline int NetworkRoute::route_ip_size() const {
  return route_ip_.size();
}
inline void NetworkRoute::clear_route_ip() {
  route_ip_.Clear();
}
inline const ::std::string& NetworkRoute::route_ip(int index) const {
  return route_ip_.Get(index);
}
inline ::std::string* NetworkRoute::mutable_route_ip(int index) {
  return route_ip_.Mutable(index);
}
inline void NetworkRoute::set_route_ip(int index, const ::std::string& value) {
  route_ip_.Mutable(index)->assign(value);
}
inline void NetworkRoute::set_route_ip(int index, const char* value) {
  route_ip_.Mutable(index)->assign(value);
}
inline void NetworkRoute::set_route_ip(int index, const char* value, size_t size) {
  route_ip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkRoute::add_route_ip() {
  return route_ip_.Add();
}
inline void NetworkRoute::add_route_ip(const ::std::string& value) {
  route_ip_.Add()->assign(value);
}
inline void NetworkRoute::add_route_ip(const char* value) {
  route_ip_.Add()->assign(value);
}
inline void NetworkRoute::add_route_ip(const char* value, size_t size) {
  route_ip_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkRoute::route_ip() const {
  return route_ip_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkRoute::mutable_route_ip() {
  return &route_ip_;
}

// optional string index = 6;
inline bool NetworkRoute::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkRoute::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkRoute::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkRoute::clear_index() {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& NetworkRoute::index() const {
  return *index_;
}
inline void NetworkRoute::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void NetworkRoute::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void NetworkRoute::set_index(const char* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkRoute::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  return index_;
}
inline ::std::string* NetworkRoute::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetworkRoute::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NetworkInterface

// optional string index = 2;
inline bool NetworkInterface::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkInterface::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkInterface::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkInterface::clear_index() {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& NetworkInterface::index() const {
  return *index_;
}
inline void NetworkInterface::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void NetworkInterface::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void NetworkInterface::set_index(const char* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkInterface::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    index_ = new ::std::string;
  }
  return index_;
}
inline ::std::string* NetworkInterface::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NetworkInterface::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::kEmptyString) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string ip_cidr = 4;
inline int NetworkInterface::ip_cidr_size() const {
  return ip_cidr_.size();
}
inline void NetworkInterface::clear_ip_cidr() {
  ip_cidr_.Clear();
}
inline const ::std::string& NetworkInterface::ip_cidr(int index) const {
  return ip_cidr_.Get(index);
}
inline ::std::string* NetworkInterface::mutable_ip_cidr(int index) {
  return ip_cidr_.Mutable(index);
}
inline void NetworkInterface::set_ip_cidr(int index, const ::std::string& value) {
  ip_cidr_.Mutable(index)->assign(value);
}
inline void NetworkInterface::set_ip_cidr(int index, const char* value) {
  ip_cidr_.Mutable(index)->assign(value);
}
inline void NetworkInterface::set_ip_cidr(int index, const char* value, size_t size) {
  ip_cidr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkInterface::add_ip_cidr() {
  return ip_cidr_.Add();
}
inline void NetworkInterface::add_ip_cidr(const ::std::string& value) {
  ip_cidr_.Add()->assign(value);
}
inline void NetworkInterface::add_ip_cidr(const char* value) {
  ip_cidr_.Add()->assign(value);
}
inline void NetworkInterface::add_ip_cidr(const char* value, size_t size) {
  ip_cidr_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkInterface::ip_cidr() const {
  return ip_cidr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkInterface::mutable_ip_cidr() {
  return &ip_cidr_;
}

// repeated string dns_server = 6;
inline int NetworkInterface::dns_server_size() const {
  return dns_server_.size();
}
inline void NetworkInterface::clear_dns_server() {
  dns_server_.Clear();
}
inline const ::std::string& NetworkInterface::dns_server(int index) const {
  return dns_server_.Get(index);
}
inline ::std::string* NetworkInterface::mutable_dns_server(int index) {
  return dns_server_.Mutable(index);
}
inline void NetworkInterface::set_dns_server(int index, const ::std::string& value) {
  dns_server_.Mutable(index)->assign(value);
}
inline void NetworkInterface::set_dns_server(int index, const char* value) {
  dns_server_.Mutable(index)->assign(value);
}
inline void NetworkInterface::set_dns_server(int index, const char* value, size_t size) {
  dns_server_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetworkInterface::add_dns_server() {
  return dns_server_.Add();
}
inline void NetworkInterface::add_dns_server(const ::std::string& value) {
  dns_server_.Add()->assign(value);
}
inline void NetworkInterface::add_dns_server(const char* value) {
  dns_server_.Add()->assign(value);
}
inline void NetworkInterface::add_dns_server(const char* value, size_t size) {
  dns_server_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkInterface::dns_server() const {
  return dns_server_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkInterface::mutable_dns_server() {
  return &dns_server_;
}

// repeated .cloudos.config.os.NetworkRoute route = 10;
inline int NetworkInterface::route_size() const {
  return route_.size();
}
inline void NetworkInterface::clear_route() {
  route_.Clear();
}
inline const ::cloudos::config::os::NetworkRoute& NetworkInterface::route(int index) const {
  return route_.Get(index);
}
inline ::cloudos::config::os::NetworkRoute* NetworkInterface::mutable_route(int index) {
  return route_.Mutable(index);
}
inline ::cloudos::config::os::NetworkRoute* NetworkInterface::add_route() {
  return route_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudos::config::os::NetworkRoute >&
NetworkInterface::route() const {
  return route_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudos::config::os::NetworkRoute >*
NetworkInterface::mutable_route() {
  return &route_;
}

// -------------------------------------------------------------------

// SSHTunnel

// optional string tunnel_name = 2;
inline bool SSHTunnel::has_tunnel_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSHTunnel::set_has_tunnel_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSHTunnel::clear_has_tunnel_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSHTunnel::clear_tunnel_name() {
  if (tunnel_name_ != &::google::protobuf::internal::kEmptyString) {
    tunnel_name_->clear();
  }
  clear_has_tunnel_name();
}
inline const ::std::string& SSHTunnel::tunnel_name() const {
  return *tunnel_name_;
}
inline void SSHTunnel::set_tunnel_name(const ::std::string& value) {
  set_has_tunnel_name();
  if (tunnel_name_ == &::google::protobuf::internal::kEmptyString) {
    tunnel_name_ = new ::std::string;
  }
  tunnel_name_->assign(value);
}
inline void SSHTunnel::set_tunnel_name(const char* value) {
  set_has_tunnel_name();
  if (tunnel_name_ == &::google::protobuf::internal::kEmptyString) {
    tunnel_name_ = new ::std::string;
  }
  tunnel_name_->assign(value);
}
inline void SSHTunnel::set_tunnel_name(const char* value, size_t size) {
  set_has_tunnel_name();
  if (tunnel_name_ == &::google::protobuf::internal::kEmptyString) {
    tunnel_name_ = new ::std::string;
  }
  tunnel_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHTunnel::mutable_tunnel_name() {
  set_has_tunnel_name();
  if (tunnel_name_ == &::google::protobuf::internal::kEmptyString) {
    tunnel_name_ = new ::std::string;
  }
  return tunnel_name_;
}
inline ::std::string* SSHTunnel::release_tunnel_name() {
  clear_has_tunnel_name();
  if (tunnel_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tunnel_name_;
    tunnel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSHTunnel::set_allocated_tunnel_name(::std::string* tunnel_name) {
  if (tunnel_name_ != &::google::protobuf::internal::kEmptyString) {
    delete tunnel_name_;
  }
  if (tunnel_name) {
    set_has_tunnel_name();
    tunnel_name_ = tunnel_name;
  } else {
    clear_has_tunnel_name();
    tunnel_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string local_ip = 4 [default = "127.0.0.1"];
inline bool SSHTunnel::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSHTunnel::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSHTunnel::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSHTunnel::clear_local_ip() {
  if (local_ip_ != _default_local_ip_) {
    local_ip_->assign(*_default_local_ip_);
  }
  clear_has_local_ip();
}
inline const ::std::string& SSHTunnel::local_ip() const {
  return *local_ip_;
}
inline void SSHTunnel::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  if (local_ip_ == _default_local_ip_) {
    local_ip_ = new ::std::string;
  }
  local_ip_->assign(value);
}
inline void SSHTunnel::set_local_ip(const char* value) {
  set_has_local_ip();
  if (local_ip_ == _default_local_ip_) {
    local_ip_ = new ::std::string;
  }
  local_ip_->assign(value);
}
inline void SSHTunnel::set_local_ip(const char* value, size_t size) {
  set_has_local_ip();
  if (local_ip_ == _default_local_ip_) {
    local_ip_ = new ::std::string;
  }
  local_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHTunnel::mutable_local_ip() {
  set_has_local_ip();
  if (local_ip_ == _default_local_ip_) {
    local_ip_ = new ::std::string(*_default_local_ip_);
  }
  return local_ip_;
}
inline ::std::string* SSHTunnel::release_local_ip() {
  clear_has_local_ip();
  if (local_ip_ == _default_local_ip_) {
    return NULL;
  } else {
    ::std::string* temp = local_ip_;
    local_ip_ = const_cast< ::std::string*>(_default_local_ip_);
    return temp;
  }
}
inline void SSHTunnel::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip_ != _default_local_ip_) {
    delete local_ip_;
  }
  if (local_ip) {
    set_has_local_ip();
    local_ip_ = local_ip;
  } else {
    clear_has_local_ip();
    local_ip_ = const_cast< ::std::string*>(_default_local_ip_);
  }
}

// optional int32 local_port = 6;
inline bool SSHTunnel::has_local_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSHTunnel::set_has_local_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSHTunnel::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSHTunnel::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 SSHTunnel::local_port() const {
  return local_port_;
}
inline void SSHTunnel::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
}

// optional string remote_ip = 8;
inline bool SSHTunnel::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSHTunnel::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSHTunnel::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSHTunnel::clear_remote_ip() {
  if (remote_ip_ != &::google::protobuf::internal::kEmptyString) {
    remote_ip_->clear();
  }
  clear_has_remote_ip();
}
inline const ::std::string& SSHTunnel::remote_ip() const {
  return *remote_ip_;
}
inline void SSHTunnel::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void SSHTunnel::set_remote_ip(const char* value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void SSHTunnel::set_remote_ip(const char* value, size_t size) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHTunnel::mutable_remote_ip() {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  return remote_ip_;
}
inline ::std::string* SSHTunnel::release_remote_ip() {
  clear_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remote_ip_;
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSHTunnel::set_allocated_remote_ip(::std::string* remote_ip) {
  if (remote_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete remote_ip_;
  }
  if (remote_ip) {
    set_has_remote_ip();
    remote_ip_ = remote_ip;
  } else {
    clear_has_remote_ip();
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 remote_port = 10;
inline bool SSHTunnel::has_remote_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSHTunnel::set_has_remote_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSHTunnel::clear_has_remote_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSHTunnel::clear_remote_port() {
  remote_port_ = 0;
  clear_has_remote_port();
}
inline ::google::protobuf::int32 SSHTunnel::remote_port() const {
  return remote_port_;
}
inline void SSHTunnel::set_remote_port(::google::protobuf::int32 value) {
  set_has_remote_port();
  remote_port_ = value;
}

// optional string remote_user = 12 [default = "root"];
inline bool SSHTunnel::has_remote_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSHTunnel::set_has_remote_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSHTunnel::clear_has_remote_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSHTunnel::clear_remote_user() {
  if (remote_user_ != _default_remote_user_) {
    remote_user_->assign(*_default_remote_user_);
  }
  clear_has_remote_user();
}
inline const ::std::string& SSHTunnel::remote_user() const {
  return *remote_user_;
}
inline void SSHTunnel::set_remote_user(const ::std::string& value) {
  set_has_remote_user();
  if (remote_user_ == _default_remote_user_) {
    remote_user_ = new ::std::string;
  }
  remote_user_->assign(value);
}
inline void SSHTunnel::set_remote_user(const char* value) {
  set_has_remote_user();
  if (remote_user_ == _default_remote_user_) {
    remote_user_ = new ::std::string;
  }
  remote_user_->assign(value);
}
inline void SSHTunnel::set_remote_user(const char* value, size_t size) {
  set_has_remote_user();
  if (remote_user_ == _default_remote_user_) {
    remote_user_ = new ::std::string;
  }
  remote_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHTunnel::mutable_remote_user() {
  set_has_remote_user();
  if (remote_user_ == _default_remote_user_) {
    remote_user_ = new ::std::string(*_default_remote_user_);
  }
  return remote_user_;
}
inline ::std::string* SSHTunnel::release_remote_user() {
  clear_has_remote_user();
  if (remote_user_ == _default_remote_user_) {
    return NULL;
  } else {
    ::std::string* temp = remote_user_;
    remote_user_ = const_cast< ::std::string*>(_default_remote_user_);
    return temp;
  }
}
inline void SSHTunnel::set_allocated_remote_user(::std::string* remote_user) {
  if (remote_user_ != _default_remote_user_) {
    delete remote_user_;
  }
  if (remote_user) {
    set_has_remote_user();
    remote_user_ = remote_user;
  } else {
    clear_has_remote_user();
    remote_user_ = const_cast< ::std::string*>(_default_remote_user_);
  }
}

// optional string key_file = 20;
inline bool SSHTunnel::has_key_file() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSHTunnel::set_has_key_file() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSHTunnel::clear_has_key_file() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSHTunnel::clear_key_file() {
  if (key_file_ != &::google::protobuf::internal::kEmptyString) {
    key_file_->clear();
  }
  clear_has_key_file();
}
inline const ::std::string& SSHTunnel::key_file() const {
  return *key_file_;
}
inline void SSHTunnel::set_key_file(const ::std::string& value) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(value);
}
inline void SSHTunnel::set_key_file(const char* value) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(value);
}
inline void SSHTunnel::set_key_file(const char* value, size_t size) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSHTunnel::mutable_key_file() {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  return key_file_;
}
inline ::std::string* SSHTunnel::release_key_file() {
  clear_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_file_;
    key_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSHTunnel::set_allocated_key_file(::std::string* key_file) {
  if (key_file_ != &::google::protobuf::internal::kEmptyString) {
    delete key_file_;
  }
  if (key_file) {
    set_has_key_file();
    key_file_ = key_file;
  } else {
    clear_has_key_file();
    key_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebProtocol

// required .cloudos.config.os.WebProtocol.Type type = 2 [default = HTTPS];
inline bool WebProtocol::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebProtocol::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebProtocol::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebProtocol::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::cloudos::config::os::WebProtocol_Type WebProtocol::type() const {
  return static_cast< ::cloudos::config::os::WebProtocol_Type >(type_);
}
inline void WebProtocol::set_type(::cloudos::config::os::WebProtocol_Type value) {
  assert(::cloudos::config::os::WebProtocol_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SSLSettings

// optional string ca_file = 2;
inline bool SSLSettings::has_ca_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSLSettings::set_has_ca_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSLSettings::clear_has_ca_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSLSettings::clear_ca_file() {
  if (ca_file_ != &::google::protobuf::internal::kEmptyString) {
    ca_file_->clear();
  }
  clear_has_ca_file();
}
inline const ::std::string& SSLSettings::ca_file() const {
  return *ca_file_;
}
inline void SSLSettings::set_ca_file(const ::std::string& value) {
  set_has_ca_file();
  if (ca_file_ == &::google::protobuf::internal::kEmptyString) {
    ca_file_ = new ::std::string;
  }
  ca_file_->assign(value);
}
inline void SSLSettings::set_ca_file(const char* value) {
  set_has_ca_file();
  if (ca_file_ == &::google::protobuf::internal::kEmptyString) {
    ca_file_ = new ::std::string;
  }
  ca_file_->assign(value);
}
inline void SSLSettings::set_ca_file(const char* value, size_t size) {
  set_has_ca_file();
  if (ca_file_ == &::google::protobuf::internal::kEmptyString) {
    ca_file_ = new ::std::string;
  }
  ca_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSLSettings::mutable_ca_file() {
  set_has_ca_file();
  if (ca_file_ == &::google::protobuf::internal::kEmptyString) {
    ca_file_ = new ::std::string;
  }
  return ca_file_;
}
inline ::std::string* SSLSettings::release_ca_file() {
  clear_has_ca_file();
  if (ca_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ca_file_;
    ca_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSLSettings::set_allocated_ca_file(::std::string* ca_file) {
  if (ca_file_ != &::google::protobuf::internal::kEmptyString) {
    delete ca_file_;
  }
  if (ca_file) {
    set_has_ca_file();
    ca_file_ = ca_file;
  } else {
    clear_has_ca_file();
    ca_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cert_file = 4;
inline bool SSLSettings::has_cert_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSLSettings::set_has_cert_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSLSettings::clear_has_cert_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSLSettings::clear_cert_file() {
  if (cert_file_ != &::google::protobuf::internal::kEmptyString) {
    cert_file_->clear();
  }
  clear_has_cert_file();
}
inline const ::std::string& SSLSettings::cert_file() const {
  return *cert_file_;
}
inline void SSLSettings::set_cert_file(const ::std::string& value) {
  set_has_cert_file();
  if (cert_file_ == &::google::protobuf::internal::kEmptyString) {
    cert_file_ = new ::std::string;
  }
  cert_file_->assign(value);
}
inline void SSLSettings::set_cert_file(const char* value) {
  set_has_cert_file();
  if (cert_file_ == &::google::protobuf::internal::kEmptyString) {
    cert_file_ = new ::std::string;
  }
  cert_file_->assign(value);
}
inline void SSLSettings::set_cert_file(const char* value, size_t size) {
  set_has_cert_file();
  if (cert_file_ == &::google::protobuf::internal::kEmptyString) {
    cert_file_ = new ::std::string;
  }
  cert_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSLSettings::mutable_cert_file() {
  set_has_cert_file();
  if (cert_file_ == &::google::protobuf::internal::kEmptyString) {
    cert_file_ = new ::std::string;
  }
  return cert_file_;
}
inline ::std::string* SSLSettings::release_cert_file() {
  clear_has_cert_file();
  if (cert_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cert_file_;
    cert_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSLSettings::set_allocated_cert_file(::std::string* cert_file) {
  if (cert_file_ != &::google::protobuf::internal::kEmptyString) {
    delete cert_file_;
  }
  if (cert_file) {
    set_has_cert_file();
    cert_file_ = cert_file;
  } else {
    clear_has_cert_file();
    cert_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key_file = 6;
inline bool SSLSettings::has_key_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSLSettings::set_has_key_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSLSettings::clear_has_key_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSLSettings::clear_key_file() {
  if (key_file_ != &::google::protobuf::internal::kEmptyString) {
    key_file_->clear();
  }
  clear_has_key_file();
}
inline const ::std::string& SSLSettings::key_file() const {
  return *key_file_;
}
inline void SSLSettings::set_key_file(const ::std::string& value) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(value);
}
inline void SSLSettings::set_key_file(const char* value) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(value);
}
inline void SSLSettings::set_key_file(const char* value, size_t size) {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  key_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SSLSettings::mutable_key_file() {
  set_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    key_file_ = new ::std::string;
  }
  return key_file_;
}
inline ::std::string* SSLSettings::release_key_file() {
  clear_has_key_file();
  if (key_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_file_;
    key_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SSLSettings::set_allocated_key_file(::std::string* key_file) {
  if (key_file_ != &::google::protobuf::internal::kEmptyString) {
    delete key_file_;
  }
  if (key_file) {
    set_has_key_file();
    key_file_ = key_file;
  } else {
    clear_has_key_file();
    key_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool allow_untrusted = 8 [default = false];
inline bool SSLSettings::has_allow_untrusted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSLSettings::set_has_allow_untrusted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSLSettings::clear_has_allow_untrusted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSLSettings::clear_allow_untrusted() {
  allow_untrusted_ = false;
  clear_has_allow_untrusted();
}
inline bool SSLSettings::allow_untrusted() const {
  return allow_untrusted_;
}
inline void SSLSettings::set_allow_untrusted(bool value) {
  set_has_allow_untrusted();
  allow_untrusted_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace os
}  // namespace config
}  // namespace cloudos

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cloudos::config::os::NetworkRoute_Type>() {
  return ::cloudos::config::os::NetworkRoute_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cloudos::config::os::WebProtocol_Type>() {
  return ::cloudos::config::os::WebProtocol_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_OS_2eNetwork_2eproto__INCLUDED
